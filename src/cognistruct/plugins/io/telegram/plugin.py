import asyncio
from typing import Optional, Dict, Any, List
import json
from datetime import datetime
import logging
import telegramify_markdown
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler

from cognistruct.core import BasePlugin, IOMessage, PluginMetadata
from cognistruct.llm.interfaces import StreamChunk
from .bot import TelegramBot
from .database import TelegramDatabase
from .handlers import TelegramHandlers
from .utils import format_message, send_content_box

# –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.getLogger("httpx").setLevel(logging.WARNING)
telegramify_logger = logging.getLogger("telegramify_markdown")
telegramify_logger.setLevel(logging.INFO)
telegramify_logger.warn = telegramify_logger.warning  # –î–æ–±–∞–≤–ª—è–µ–º –∞–ª–∏–∞—Å –¥–ª—è warn

logger = logging.getLogger(__name__)

class TelegramPlugin(BasePlugin):
    """Telegram –ø–ª–∞–≥–∏–Ω –¥–ª—è CogniStruct"""
    
    def __init__(self, telegram_user_id: str = None):
        super().__init__()
        self.bot = None
        self.db = None
        self.handlers = None
        self._current_chat_id = None  # –¢–µ–∫—É—â–∏–π —á–∞—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        self.telegram_user_id = telegram_user_id  # ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–∏–≤—è–∑–∫–∏
        
    def get_metadata(self) -> PluginMetadata:
        return PluginMetadata(
            name="telegram",
            description="Telegram –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è",
            version="1.0.0",
            priority=10
        )
        
    def set_message_handler(self, handler):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        if self.handlers:
            self.handlers.message_handler = handler
        else:
            raise RuntimeError("TelegramPlugin not initialized. Call setup() first")
        
    async def setup(self, token: str = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–≥–∏–Ω–∞
        
        Args:
            token: Telegram Bot —Ç–æ–∫–µ–Ω. –ï—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω, –±–µ—Ä–µ—Ç—Å—è –∏–∑ TELEGRAM_BOT_TOKEN
            
        Returns:
            dict: –†–µ–∑—É–ª—å—Ç–∞—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Å—Ç–∞—Ç—É—Å–µ —á–∞—Ç–∞
        """
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π
        self.register_input_type("telegram_message")
        self.register_output_type("message")
        self.register_output_type("action")
        self.register_output_type("confirmation_request")
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω
        self.token = token or os.getenv("TELEGRAM_BOT_TOKEN")
        if not self.token:
            raise ValueError("Telegram token not provided")
            
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        self.db = TelegramDatabase()
        await self.db.connect()
        
        self.bot = TelegramBot(self.token)
        self.handlers = TelegramHandlers(self.db, self.bot)
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        self.bot.add_handler(CommandHandler("start", self.handlers.handle_start))
        self.bot.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handlers.handle_message))
        self.bot.add_handler(CallbackQueryHandler(self.handlers.handle_callback_query))
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
        await self.bot.start()
        await self.bot.start_polling()
        
        result = {"status": "initialized"}
        
        # –ï—Å–ª–∏ –∑–∞–¥–∞–Ω user_id, –ø—Ä–æ–≤–µ—Ä—è–µ–º/—Å–æ–∑–¥–∞–µ–º –ø—Ä–∏–≤—è–∑–∫—É —á–∞—Ç–∞
        if self.telegram_user_id:
            chat_id = await self.check_chat_link(self.telegram_user_id)
            if chat_id:
                logger.info(f"Found existing chat link: {chat_id}")
                self._current_chat_id = chat_id
                result.update({
                    "chat_status": "linked",
                    "chat_id": chat_id
                })
            else:
                key = await self.generate_key(self.telegram_user_id)
                logger.info(f"Generated new key for user {self.telegram_user_id}: {key}")
                result.update({
                    "chat_status": "not_linked",
                    "key": key
                })
        
        logger.info("Telegram bot initialized and polling started")
        return result
        
    async def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤"""
        await self.bot.stop()
        await self.db.close()
        
    async def input_hook(self, message: IOMessage) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∏–≤—è–∑–∫—É —á–∞—Ç–∞"""
        if message.type == "telegram_message":
            chat_id = message.metadata["chat_id"]
            chat_link = await self.db.get_chat_link(chat_id)
            
            if not chat_link:
                await self.bot.send_message(
                    chat_id,
                    "–ß–∞—Ç –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start —Å —Å–µ–∫—Ä–µ—Ç–Ω—ã–º –∫–ª—é—á–æ–º"
                )
                return True
                
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º chat_id –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
            self._current_chat_id = chat_id
            return False
            
        return False
        
    async def output_hook(self, message: IOMessage) -> Optional[IOMessage]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π chat_id
        if not self._current_chat_id:
            logger.warning("No current chat_id")
            return message
            
        chat_id = self._current_chat_id
        logger.debug(f"====== Output hook called with message: {message}")
        
        try:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç—Ä–∏–º–∏–Ω–≥
            if message.type == "stream":
                current_content = ""
                typing_interval = 4.0
                last_typing = 0
                
                async for chunk in message.stream:
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞–±–æ—Ä–∞ —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º
                    current_time = time.time()
                    if current_time - last_typing >= typing_interval:
                        await self.send_typing(chat_id)
                        last_typing = current_time
                        
                    if chunk.tool_call:
                        current_content += "üîß –ò—Å–ø–æ–ª—å–∑—É—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: " + chunk.tool_call.tool + "\n"

                    if chunk.delta:
                        current_content += chunk.delta
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                boxes = await format_message(current_content)
                for item in boxes:
                    await send_content_box(self.bot, chat_id, item)
                    
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç
            elif message.type == "text":
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ LLMResponse
                content = message.content.content if hasattr(message.content, 'content') else str(message.content)
                boxes = await format_message(content)
                for item in boxes:
                    await send_content_box(self.bot, chat_id, item)
                    
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏—è (typing, etc)
            elif message.type == "action":
                await self.bot.send_chat_action(
                    chat_id=chat_id,
                    action=message.content
                )
                
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
            elif message.type == "confirmation_request":
                expires_in = message.metadata.get("expires_in", 3600)
                
                # –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
                confirmation_id = await self.db.create_confirmation(
                    message=message.content,
                    chat_id=chat_id,
                    callback_data=message.metadata.get("callback_data", ""),
                    expires_in=expires_in
                )
                
                keyboard = [
                    [
                        {"text": "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", "callback_data": f"confirm_{confirmation_id}"},
                        {"text": "‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", "callback_data": f"reject_{confirmation_id}"}
                    ]
                ]
                
                await self.bot.send_message(
                    chat_id=chat_id,
                    text=f"–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:\n\n{message.content}",
                    reply_markup={"inline_keyboard": keyboard}
                )
                    
        except Exception as e:
            logger.error(f"Error processing message: {e}", exc_info=True)
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            content = message.content.content if hasattr(message.content, 'content') else str(message.content)
            await self.bot.send_message(
                chat_id=chat_id,
                text=content
            )
                    
        return message
        
    async def check_chat_link(self, user_id: str) -> Optional[str]:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∏–≤—è–∑–∫—É —á–∞—Ç–∞ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            
        Returns:
            str: ID —á–∞—Ç–∞, –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω
            None: –µ—Å–ª–∏ —á–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
        """
        chat_data = await self.db.get_chat_by_user(user_id)
        if chat_data:
            return chat_data["chat_id"]
        return None
        
    async def get_all_chat_links(self, user_id: str) -> list[str]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ —á–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            
        Returns:
            list[str]: –°–ø–∏—Å–æ–∫ ID —á–∞—Ç–æ–≤
        """
        chats = await self.db.get_all_chats_by_user(user_id)
        return [chat["chat_id"] for chat in chats] 
        
    async def generate_key(self, user_id: str, expires_in: int = 3600) -> str:
        """
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–ª—é—á –¥–ª—è –ø—Ä–∏–≤—è–∑–∫–∏ —á–∞—Ç–∞
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            expires_in: –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∫–ª—é—á–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1 —á–∞—Å)
            
        Returns:
            str: –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á
        """
        return await self.db.generate_secret_key(user_id, expires_in)
        
    async def get_chat_id(self, user_id: str) -> Optional[str]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç ID —á–∞—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            
        Returns:
            str: ID —á–∞—Ç–∞, –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω
            None: –µ—Å–ª–∏ —á–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
        """
        chat_data = await self.db.get_chat_by_user(user_id)
        if chat_data:
            return chat_data["chat_id"]
        return None
        
    async def send_typing(self, chat_id: str):
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–±–æ—Ä–∞ —Ç–µ–∫—Å—Ç–∞
        
        Args:
            chat_id: ID —á–∞—Ç–∞
        """
        await self.bot.send_chat_action(chat_id=chat_id, action="typing")
        
    async def send_message_to_user(self, user_id: str, text: str, **kwargs):
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            text: –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
            **kwargs: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
        """
        chat_id = await self.get_chat_id(user_id)
        if chat_id:
            await self.bot.send_message(chat_id=chat_id, text=text, **kwargs)
        else:
            logger.warning(f"No linked chat found for user {user_id}")
            
    async def request_confirmation(self, user_id: str, message: str, expires_in: int = 3600) -> str:
        """
        –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            message: –¢–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞
            expires_in: –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
            
        Returns:
            str: ID –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        """
        chat_id = await self.get_chat_id(user_id)
        if not chat_id:
            raise ValueError(f"No linked chat found for user {user_id}")
            
        confirmation_id = await self.db.create_confirmation(
            message=message,
            chat_id=chat_id,
            expires_in=expires_in
        )
        
        keyboard = [
            [
                {"text": "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", "callback_data": f"confirm_{confirmation_id}"},
                {"text": "‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", "callback_data": f"reject_{confirmation_id}"}
            ]
        ]
        
        await self.bot.send_message(
            chat_id=chat_id,
            text=f"–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:\n\n{message}",
            reply_markup={"inline_keyboard": keyboard}
        )
        
        return confirmation_id 
        
    async def send_welcome_message(self, chat_id: str):
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"""
        await self.output_hook(
            IOMessage(
                type="text",
                content="–ü—Ä–∏–≤–µ—Ç! –Ø –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ. –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∏ —è –ø–æ—Å—Ç–∞—Ä–∞—é—Å—å –ø–æ–º–æ—á—å.",
                metadata={"chat_id": chat_id}
            )
        ) 